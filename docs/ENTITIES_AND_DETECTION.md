# Сущности книги и как они определяются в коде

Описание: какие сущности мы извлекаем из текста учебника, по каким правилам (регулярные выражения и границы) они определяются, и где это реализовано.

---

## 1. Текущие сущности и место в БД

| Сущность | Таблица/поля | Описание |
|----------|--------------|----------|
| **Книга** | `books` | Метаданные: subject, grade, title, authors. |
| **PDF-источник** | `pdf_sources` | Ссылка на файл (minio_key), статус обработки. |
| **Страница** | `pdf_pages` | page_num, **ocr_text** (нормализованный текст страницы), ocr_confidence. Поле image_minio_key есть, но **сейчас не заполняется** — изображения страниц/рисунков из учебника не извлекаются и не сохраняются. |
| **Теория параграфа** | `section_theory` | section (например §7), theory_text, page_ref. Текст параграфа для LLM (ответы на контрольные вопросы, обоснование решений). |
| **Задача/вопрос/упражнение** | `problems` | number, section, problem_text (условие), solution_text (блок после «Решение.»/«Ответ.»), answer_text (из постобработки link_answers), page_ref. |
| **Подпункты задачи** | `problem_parts` | part_number, part_text, answer_text — для задач вида «1) … 2) …». |

Теория и задачи определяются **только по тексту** (ocr_text): разметка в виде заголовков (§, «Задача», «Решение.» и т.д.). Рисунки, схемы и их подписи в текст OCR попадают как строки (например «рис. 1»), но **отдельно не выделяются**, изображения не вырезаются и не сохраняются.

---

## 2. Как определяется теория (текущий код)

**Файл:** `apps/worker/ingestion.py`, функция `extract_and_save_section_theory()`.

**Вход:** все страницы источника с непустым `ocr_text`, в порядке page_num.

**Логика построчно:**

1. **Начало параграфа (теории)** — строка совпадает с одним из паттернов:
   - `RE_SECTION_HEADER`: начало строки → «§ N» или «$ N» или «Параграф N» (N — число), регистронезависимо.
   - Регулярное выражение:  
     `^\s*[§\$]\s*(\d+)[.,\s]` или `^\s*Параграф\s*(\d+)[.,\s]`.
   - После совпадения начинается новый блок теории с меткой `§{num}` (например §1, §7).

2. **Конец блока теории** — строка совпадает с началом блока заданий:
   - `RE_TASK_BLOCK_START`: начало строки → «Задачи», «Упражнения», «Вопросы к параграфу», «Контрольные задания», «Практические задания» (с опциональными «.» или «:»).
   - Регулярное выражение:  
     `^\s*(?:Задачи|Упражнения|Вопросы\s+к\s+параграфу|Контрольные\s+задания|Практические\s+задания)\s*[.:]?`.
   - Всё между «§ N» и этой строкой считается текстом параграфа и накапливается в текущем блоке теории.

3. **Сборка по страницам:** текст между двумя такими границами (или от § до конца страницы) накапливается в `current_text`; при следующем § или при «Задачи»/«Упражнения» блок сбрасывается (flush) и попадает в список блоков с меткой секции и диапазоном страниц (start_page, end_page).

4. **Объединение по §:** блоки с одной и той же меткой (например несколько кусков §1 с разных страниц) объединяются в один текст через `\n\n`; в `section_theory` сохраняется одна запись на (book_id, section) с объединённым theory_text и page_ref «стр. X–Y».

**Итог:** теория — это текст от заголовка параграфа (§ N / Параграф N) до заголовка блока заданий (Задачи/Упражнения/…) или до следующего §. Определение только по строкам в ocr_text, без анализа изображений.

---

## 3. Как определяются задачи и решения (текущий код)

**Файл:** `apps/worker/ingestion.py`, функция `segment_problems(text, page_num)`.

**Вход:** текст одной страницы (нормализованный ocr_text), номер страницы.

**Логика построчно:**

1. **Начало задачи** — строка совпадает с одним из паттернов (порядок важен, более специфичные раньше):
   - Контрольное задание / Контрольные задания (№ N, N, (N))
   - Практическое задание
   - Задача (N). / Задача N
   - Упражнение N / Упражнение (N)
   - Вопрос (№ N, N)
   - Вопросы (к N, № N)
   - Задание (N) / Задание N / Задание № N
   - § N / Параграф N
   - Exercise N
   - № N
   - «N. » в начале строки (например «1. Текст»)
   - «N) » в начале строки (например «1) Текст»)

   При совпадении начинается новая задача; номер берётся из первой захватывающей группы (например число после «Задача (» или «№ »).

2. **Граница «условие / решение»:**
   - `RE_SOLUTION_START`: строка целиком — «Решение.» или «Ответ.» (в том числе с пробелами между буквами, например «Р е ш е н и е .» после OCR).
   - Регулярное выражение:  
     `^\s*Р\s*е\s*ш\s*е\s*н\s*и\s*е\s*\.|^\s*Решение\s*\.` и то же для «Ответ».
   - Текст до этой строки — условие текущей задачи (problem_text); текст после неё до следующего начала задачи — решение (solution_text) и привязывается к этой задаче.

3. **Накопление:** строки между двумя «началами задачи» или между «началом задачи» и «Решение.»/«Ответ.» накапливаются в текущий блок; при встрече «Решение.»/«Ответ.» накопленное условие сохраняется как одна задача, затем накапливается решение до следующей задачи.

**Итог:** задача — это блок текста от одной из перечисленных меток начала до следующей такой метки или до «Решение.»/«Ответ.»; решение — текст после «Решение.»/«Ответ.» до следующей задачи. Подписи рисунков («рис. 1» и т.д.) могут попадать в problem_text/theory_text как обычные строки, но отдельно не классифицируются и не связываются с файлами изображений.

---

## 4. Что сейчас не делается

- **Изображения из учебника:** не извлекаются, не сохраняются, не привязываются к страницам или к теории/задачам. Поле `pdf_pages.image_minio_key` не заполняется в пайплайне ingestion.
- **Подписи рисунков/схем:** строки вида «рис. 1 "название"», «схема. 1» обрабатываются как часть текста; отдельная сущность «рисунок с подписью» и связь «задача/теория → рисунок» не создаётся.
- **Два прохода OCR и сравнение:** используется один OCR (Tesseract); второй проход и анализ различий между двумя текстами не реализованы.
- **Нормализация силами ИИ:** после OCR используется только `clean_ocr_text()` (правила/словарь); этап «ИИ читает оба текста и нормализует артефакты» не делается.

---

## 5. Целевая схема (на будущее)

Описанная вами схема, которую предполагается реализовать дальше:

1. **Первый проход OCR:** Tesseract → текст итерации 1, сохранение (например отдельное поле или таблица).
2. **Второй проход OCR:** более точная модель → текст итерации 2, сохранение.
3. **Сравнение и нормализация:** ИИ читает оба результата (целиком, но частями — равными чанками, чтобы не переполнять контекст), находит артефакты и ошибки, выдаёт нормализованный текст. Итог пишется в ocr_text (или в отдельное поле «нормализованный текст»).
4. **Изображения из учебника:**
   - Определить на каких страницах есть рисунки/схемы; вырезать области изображений из PDF/рендера страницы и сохранять как отдельные файлы (например в MinIO), привязка к pdf_page и, при необходимости, к bbox/номеру на странице.
   - В тексте найти подписи вида «рис. N "название"», «схема. N "название"» и т.п. (порядковая нумерация).
   - Связать сохранённое изображение с подписью (страница + номер/название) и с сущностями (теория, вопрос, задача), в которых эта подпись упоминается — чтобы в интерфейсе/ответах можно было показывать «место рисунка» и при необходимости само изображение.

Для реализации этого потребуется: расширение схемы БД (хранение двух вариантов OCR, нормализованного текста, таблица рисунков с привязкой к странице и к теории/задачам), пайплайн двух проходов OCR, джоба/скрипт сравнения и нормализации по чанкам, а также этап извлечения изображений и разбора подписей. Ниже в `docs/PIPELINE_FUTURE.md` эта схема зафиксирована как целевая.
