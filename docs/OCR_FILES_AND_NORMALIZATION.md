# OCR: файлы вместо прямой записи в БД. Нормализация по файлам

Цель: в БД попадает только **проверенный, нормализованный** результат. Сырой вывод OCR и промежуточные варианты живут в **файлах** — так удобнее сравнивать системы OCR, проверять человеку и подавать чанками в ИИ для нормализации без повторного запуска OCR.

---

## 1. Принцип

| Этап | Где хранится | Зачем |
|------|-------------|--------|
| **OCR (сырой результат)** | **Файлы** (например `.md` в каталоге `data/ocr_raw/`) | Сравнение Tesseract / EasyOCR / другой модели; чтение и проверка человеком; один раз распознали — дальше работаем с файлом. |
| **Нормализация** | Читает из файла(ов), пишет в **файл(ы)** (например `data/ocr_normalized/`) | Не перезапускаем OCR — оттачиваем нормализацию на уже полученном тексте. Можно запускать многократно (правила, словарь, ИИ). |
| **Проверенный итог** | **БД** (`pdf_pages.ocr_text` и далее сегментация) | В БД попадает только финальный, выверенный текст — для поиска, теории, задач, ответов. |

ИИ анализирует постранично/чанками именно **файлы** (нормально читать по частям, без вытаскивания из БД), а в БД уходит уже результат после нормализации (и при необходимости проверки).

---

## 2. Формат файлов после OCR

Требования: удобно и нейросети, и человеку; явная структура по **страницам**, при возможности по **параграфам** и **разделам**. Подходящий вариант — **Markdown (.md)**.

### 2.1 Вариант: один файл на источник (книгу/PDF)

Путь, например:  
`data/ocr_raw/{book_id}/{pdf_source_id}_{model}.md`  
или  
`data/ocr_raw/{book_id}/source_{pdf_source_id}_tesseract.md`.

Структура внутри файла:

```markdown
# Книга {book_id}, источник {pdf_source_id}, модель {model}

## Страница 1
{сырой текст страницы 1}

## Страница 2
{сырой текст страницы 2}

## Страница N
...
```

При постраничной подаче в ИИ читаем файл и режем по заголовкам `## Страница N`.

### 2.2 Вариант: один файл на страницу

Путь:  
`data/ocr_raw/{book_id}/{pdf_source_id}/page_{page_num:04d}.md`  
например `data/ocr_raw/1/1/page_0001.md`.

Внутри — только текст одной страницы (при необходимости с минимальным frontmatter: `page_num`, `model`). Удобно для сравнения двух OCR по одной и той же странице (два файла с суффиксом модели или в подкаталогах `tesseract/`, `easyocr/`).

### 2.3 Единый формат для сырого и нормализованного

- **Сырой OCR:** `data/ocr_raw/...` — структура по страницам (и при возможности по параграфам/разделам, если уже выделили).
- **После нормализации:** `data/ocr_normalized/...` — та же структура (те же заголовки страниц/параграфов), чтобы ИИ и скрипты работали с тем же разбиением.

Пример с параграфами (когда есть разметка §):

```markdown
# Книга 1, источник 1, Tesseract

## Страница 5
### § 3
Текст параграфа 3...

### § 4
Текст параграфа 4...

## Страница 6
...
```

Так и человеку удобно читать, и нейросеть получает явные границы страниц/параграфов для чанков.

---

## 3. Сравнение разных систем OCR

Один и тот же PDF можно прогнать разными движками и сохранить в разные файлы, например:

- `data/ocr_raw/1/1_tesseract.md`
- `data/ocr_raw/1/1_easyocr.md`
- `data/ocr_raw/1/1_paddleocr.md`

Или постранично:

- `data/ocr_raw/1/1/tesseract/page_0001.md`
- `data/ocr_raw/1/1/easyocr/page_0001.md`

Сравнение: дифф файлов, визуальное сравнение в редакторе, или скрипт/ИИ, который читает пару файлов и выдаёт отличия. В БД при этом ничего сырого не попадает — только после выбора/нормализации.

---

## 4. Нормализация без повторного OCR

1. **Вход:** файл(ы) из `data/ocr_raw/...` (один раз полученные с любой моделью OCR).
2. **Шаг нормализации:** скрипт или пайплайн читает эти файлы, применяет:
   - правила и словарь (например `clean_ocr_text`);
   - при необходимости — ИИ по чанкам (равные части по страницам/параграфам из того же .md).
3. **Выход:** файл(ы) в `data/ocr_normalized/...` с той же структурой (страницы, параграфы).
4. **Итерации:** меняем правила или промпты ИИ и заново запускаем нормализацию **по тем же raw-файлам** — OCR заново не дергаем.

После удовлетворённости результатом нормализованный текст используется для загрузки в БД (и сегментации теории/задач).

---

## 5. Загрузка в БД только проверенного результата

Отдельный шаг (скрипт или шаг пайплайна):

- Читает **нормализованные** файлы из `data/ocr_normalized/...`.
- По страницам (и при необходимости параграфам) заполняет:
  - `pdf_pages.ocr_text` — только этот итоговый текст;
  - дальше — сегментация теории, задач и т.д. по уже проверенному тексту.

Сырые OCR и промежуточные варианты в БД не пишутся (или пишутся опционально в служебные поля/таблицы для отладки, но не в основной `ocr_text` для поиска и ответов).

---

## 6. ИИ постранично по файлам

- Нормализация: читаем .md, режем по `## Страница N` (или по параграфам) — получаем чанки равного объёма.
- Каждый чанк отправляем в ИИ (например «здесь сырой OCR страниц 5–10, предложи нормализованный текст»).
- Ответ ИИ записываем в соответствующие разделы нормализованного файла.

Так контекстное окно не переполняется, границы страниц/параграфов сохраняются, а источник данных — файлы, а не БД.

---

## 7. Текущее состояние

- **Реализовано (ingestion + ocr_files):**
  1. OCR (EasyOCR / Tesseract) по всем страницам → запись в **файл** `data/ocr_raw/{book_id}/{pdf_source_id}_{model}.md` (формат .md по страницам: `## Страница N`).
  2. Нормализация (ocr_cleaner) по страницам → запись в `data/ocr_normalized/{book_id}/{pdf_source_id}.md`.
  3. Импорт в БД: только нормализованный текст в `pdf_pages.ocr_text`, затем сегментация задач и теории — в БД только этот результат.
  4. **Импорт без OCR:** `import_from_normalized_file(pdf_source_id)` читает нормализованный файл и заполняет страницы/задачи/теорию (удобно после ручного правки .md или смены нормализации).
- **Дальше:** опционально второй проход OCR в отдельный файл для сравнения; нормализация по чанкам через ИИ по файлам.

Формат (md с разбиением по страницам и при возможности по параграфам/разделам) можно считать общим для сырого и нормализованного вариантов; при необходимости позже добавить единый schema (например frontmatter с page_num, section, model) для скриптов и ИИ.
